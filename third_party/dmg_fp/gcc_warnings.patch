Index: dtoa.cc
--- dtoa.cc    (old copy)
+++ dtoa.cc    (working copy)
@@ -172,6 +172,10 @@
  */
 
 #define IEEE_8087
+#if defined(__GNUC__)
+// Make gcc 4.3+ warnings about parentheses non-fatal warnings.
+#pragma GCC diagnostic warning "-Wparentheses"
+#endif
 
 #ifndef Long
 #define Long long
@@ -515,7 +519,7 @@ Balloc
 #endif
 
 	ACQUIRE_DTOA_LOCK(0);
-	if (rv = freelist[k]) {
+	if ((rv = freelist[k])) {
 		freelist[k] = rv->next;
 		}
 	else {
@@ -794,7 +798,7 @@ mult
 	xc0 = c->x;
 #ifdef ULLong
 	for(; xb < xbe; xc0++) {
-		if (y = *xb++) {
+		if ((y = *xb++)) {
 			x = xa;
 			xc = xc0;
 			carry = 0;
@@ -876,7 +880,7 @@ pow5mult
 	int i;
 	static int p05[3] = { 5, 25, 125 };
 
-	if (i = k & 3)
+	if ((i = k & 3))
 		b = multadd(b, p05[i-1], 0);
 
 	if (!(k >>= 2))
@@ -957,7 +961,7 @@ lshift
 			z = *x++ >> k1;
 			}
 			while(x < xe);
-		if (*x1 = z)
+		if ((*x1 = z))
 			++n1;
 		}
 #else
@@ -1259,12 +1263,12 @@ d2b
 	z |= Exp_msk11;
 #endif
 #else
-	if (de = (int)(d0 >> Exp_shift))
+	if ((de = (int)(d0 >> Exp_shift)))
 		z |= Exp_msk1;
 #endif
 #ifdef Pack_32
-	if (y = d1) {
-		if (k = lo0bits(&y)) {
+	if ((y = d1)) {
+		if ((k = lo0bits(&y))) {
 			x[0] = y | z << 32 - k;
 			z >>= k;
 			}
@@ -1452,13 +1456,13 @@ match
 #ifdef KR_headers
 	(sp, t) char **sp, *t;
 #else
-	(CONST char **sp, char *t)
+	(CONST char **sp, CONST char *t)
 #endif
 {
 	int c, d;
 	CONST char *s = *sp;
 
-	while(d = *t++) {
+	while((d = *t++)) {
 		if ((c = *++s) >= 'A' && c <= 'Z')
 			c += 'a' - 'A';
 		if (c != d)
@@ -1490,7 +1494,7 @@ hexnan
 		++s;
 	if (s[1] == '0' && (s[2] == 'x' || s[2] == 'X'))
 		s += 2;
-	while(c = *(CONST unsigned char*)++s) {
+	while((c = *(CONST unsigned char*)++s)) {
 		if (c >= '0' && c <= '9')
 			c -= '0';
 		else if (c >= 'a' && c <= 'f')
@@ -1518,7 +1522,7 @@ hexnan
 					*sp = s + 1;
 					break;
 					}
-				} while(c = *++s);
+				} while((c = *++s));
 			break;
 			}
 #endif
@@ -1852,7 +1856,7 @@ strtod
 	/* Get starting approximation = rv * 10**e1 */
 
 	if (e1 > 0) {
-		if (i = e1 & 15)
+		if ((i = e1 & 15))
 			dval(rv) *= tens[i];
 		if (e1 &= ~15) {
 			if (e1 > DBL_MAX_10_EXP) {
@@ -1912,7 +1916,7 @@ strtod
 		}
 	else if (e1 < 0) {
 		e1 = -e1;
-		if (i = e1 & 15)
+		if ((i = e1 & 15))
 			dval(rv) /= tens[i];
 		if (e1 >>= 4) {
 			if (e1 >= 1 << n_bigtens)
@@ -2580,7 +2584,7 @@ rv_alloc(int i)
 
 	j = sizeof(ULong);
 	for(k = 0;
-		sizeof(Bigint) - sizeof(ULong) - sizeof(int) + j <= i;
+		sizeof(Bigint) - sizeof(ULong) - sizeof(int) + j <= (size_t)i;
 		j <<= 1)
 			k++;
 	r = (int*)Balloc(k);
@@ -2596,13 +2600,13 @@ rv_alloc(int i)
 #ifdef KR_headers
 nrv_alloc(s, rve, n) char *s, **rve; int n;
 #else
-nrv_alloc(char *s, char **rve, int n)
+nrv_alloc(CONST char *s, char **rve, int n)
 #endif
 {
 	char *rv, *t;
 
 	t = rv = rv_alloc(n);
-	while(*t = *s++) t++;
+	while((*t = *s++)) t++;
 	if (rve)
 		*rve = t;
 	return rv;
@@ -2707,7 +2711,7 @@ dtoa
 		to hold the suppressed trailing zeros.
 	*/
 
-	int bbits, b2, b5, be, dig, i, ieps, ilim, ilim0, ilim1,
+	int bbits, b2, b5, be, dig, i, ieps, ilim = 0, ilim0, ilim1 = 0,
 		j, j1, k, k0, k_check, leftright, m2, m5, s2, s5,
 		spec_case, try_quick;
 	Long L;
@@ -2792,7 +2796,7 @@ dtoa
 #ifdef Sudden_Underflow
 	i = (int)(word0(d) >> Exp_shift1 & (Exp_mask>>Exp_shift1));
 #else
-	if (i = (int)(word0(d) >> Exp_shift1 & (Exp_mask>>Exp_shift1))) {
+	if ((i = (int)(word0(d) >> Exp_shift1 & (Exp_mask>>Exp_shift1)))) {
 #endif
 		dval(d2) = dval(d);
 		word0(d2) &= Frac_mask1;
@@ -2946,7 +2950,7 @@ dtoa
 					}
 			dval(d) /= ds;
 			}
-		else if (j1 = -k) {
+		else if ((j1 = -k)) {
 			dval(d) *= tens[j1 & 0xf];
 			for(j = j1 >> 4; j; j >>= 1, i++)
 				if (j & 1) {
@@ -3107,7 +3111,7 @@ dtoa
 				Bfree(b);
 				b = b1;
 				}
-			if (j = b5 - m5)
+			if ((j = b5 - m5))
 				b = pow5mult(b, j);
 			}
 		else
@@ -3145,7 +3149,7 @@ dtoa
 	 * can do shifts and ors to compute the numerator for q.
 	 */
 #ifdef Pack_32
-	if (i = ((s5 ? 32 - hi0bits(S->x[S->wds-1]) : 1) + s2) & 0x1f)
+	if ((i = ((s5 ? 32 - hi0bits(S->x[S->wds-1]) : 1) + s2) & 0x1f))
 		i = 32 - i;
 #else
 	if (i = ((s5 ? 32 - hi0bits(S->x[S->wds-1]) : 1) + s2) & 0xf)
@@ -3322,7 +3326,9 @@ dtoa
 		++*s++;
 		}
 	else {
+#ifdef Honor_FLT_ROUNDS
  trimzeros:
+#endif
 		while(*--s == '0');
 		s++;
 		}
Index: g_fmt.cc
--- g_fmt.cc   (old copy)
+++ g_fmt.cc   (new copy)
@@ -46,14 +46,14 @@ g_fmt(register char *b, double x)
 	if (sign)
 		*b++ = '-';
 	if (decpt == 9999) /* Infinity or Nan */ {
-		while(*b++ = *s++);
+		while((*b++ = *s++));
 		goto done0;
 		}
 	if (decpt <= -4 || decpt > se - s + 5) {
 		*b++ = *s++;
 		if (*s) {
 			*b++ = '.';
-			while(*b = *s++)
+			while((*b = *s++))
 				b++;
 			}
 		*b++ = 'e';
@@ -79,10 +79,10 @@ g_fmt(register char *b, double x)
 		*b++ = '.';
 		for(; decpt < 0; decpt++)
 			*b++ = '0';
-		while(*b++ = *s++);
+		while((*b++ = *s++));
 		}
 	else {
-		while(*b = *s++) {
+		while((*b = *s++)) {
 			b++;
 			if (--decpt == 0 && *s)
 				*b++ = '.';
@@ -93,7 +93,9 @@ g_fmt(register char *b, double x)
 		}
  done0:
 	freedtoa(s0);
+#ifdef IGNORE_ZERO_SIGN
  done:
+#endif
 	return b0;
 	}
 
